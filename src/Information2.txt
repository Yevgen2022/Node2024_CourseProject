Базова конфігурація (рекомендована)

Cookie

httpOnly: увімкнено (щоб JS не читав).

Dev (один сайт або dev-проксі): SameSite=Lax, Secure=false, без Max-Age/Expires → сесійна cookie зникає при закритті браузера.

Якщо фронт і бек на РІЗНИХ origin/портах: потрібно SameSite=None + Secure=true (HTTPS обов’язково), і на фронті credentials: 'include'. Інакше браузер не надсилатиме cookie.
Найпростіше — уникати cross-site: подати фронт через той самий домен/проксі.

Ім’я cookie: коротке (auth). Домен/шлях — за потреби.

Сховище сесій (таблиця authkey)

Поля мінімум: authkey (PK, випадковий токен), userId, createdAt, expiresAt.

(Опційно) revokedAt для ручного відкликання.

Індекси: по userId, по expiresAt.

Строк дії (TTL)

Обов’язково ставимо expiresAt.

Простий варіант без “пролонгації”: 12 год (адмінку інколи роблять 8–12 год). Хочеш суворіше — 2–4 год.

Якщо потрібно “жити, поки активний”: робимо rolling inactivity (на кожен запит або раз на N хв оновлюємо expiresAt, але також тримаємо абсолютний ліміт, напр. 12 год).

Перевірка на кожному запиті (middleware)

Є cookie → шукаємо authkey у БД → перевіряємо expiresAt.

Протерміновано? Не пускаємо й (за бажанням) одразу видаляємо запис.

Валідно? Підвішуємо користувача в req.user.

Логін

Перевіряємо email/пароль.

Створюємо новий authkey із expiresAt = now + TTL.

(Політика сесій) Рекомендую “1 користувач — 1 активна сесія”: перед створенням видали старі ключі цього userId.

Логаут

Видаляємо відповідний authkey у БД і відправляємо очистку cookie. Подвійна дія — обов’язково.

Прибирання

Кожні, скажімо, 10–60 хв видаляй прострочені ключі (expiresAt < now). Простий крон/воркер.

Захист Admin

Бекенд: усі адмін-ендпоїнти — тільки через перевірене req.user.

Фронтенд (SPA): на старті роби перевірку “/me”. Якщо 401 — миттєвий редірект на логін.

Не кешуй адмінську HTML-відповідь: Cache-Control: no-store.

CSRF (важливо)

Якщо фронт і бек на одному домені (або через один реверс-проксі) і cookie не крос-сайт — достатньо SameSite=Lax/Strict, ризик CSRF істотно зменшено.

Якщо крос-сайт і мусиш ставити SameSite=None → додай CSRF-токен (synchronizer token або double-submit) і обмеж CORS тільки на свій фронт.

Альтернатива (коли-небудь): перейти на header-бейрер (JWT) замість cookie — тоді CSRF не актуальний, але це вже інша модель.

Значення “за замовчуванням”, щоб не думати

TTL authkey: 12 год (без пролонгації).

Cookie: сесійна (без Max-Age/Expires), httpOnly=true.

Dev без cross-site → SameSite=Lax, Secure=false.

Prod same-origin → SameSite=Lax або Strict, Secure=true (бо HTTPS).

Prod cross-origin → SameSite=None, Secure=true, + CSRF-токен і CORS credentials:true, origin:<твій фронт>.

Політика сесій: 1 активна сесія на користувача.

Хаускіпінг: чистити прострочені ключі щогодини.

Логаут: видалити ключ у БД + стерти cookie.

Як зрозуміти, що все працює правильно (перевірки)

Після логіна /me повертає користувача; після логаута — 401.

Закрив браузер → відкрив знову → якщо пройшло більше за TTL, /me дає 401.

Змінив пароль (опційно) → старі сесії зникли (якщо увімкнено “1 сесія”).

На крос-сайті: бачиш, що cookie реально надсилаються тільки з credentials: include, і CSRF-токен обов’язково перевіряється.